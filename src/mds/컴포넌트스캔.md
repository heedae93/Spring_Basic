# 컴포넌트 스캔과 의존관계 자동 주입

지금까지는 스프링 빈을 등록하기 위해  
자바 코드의 `@Bean` 이나 XML의 `<bean>` 등을 사용해  
설정 정보에 직접 스프링 빈을 하나하나 나열했다.

예제에서는 몇 개 되지 않았지만,
실제 프로젝트에서는 스프링 빈이 수십, 수백 개가 되기 쉽다.

- 설정 정보가 길어진다
- 빈 등록을 누락하기 쉽다
- 반복 작업이 많아진다
- 무엇보다 **귀찮다**

그래서 스프링은  
**설정 정보 없이도 스프링 빈을 자동으로 등록하는 기능**을 제공하는데,
이것이 바로 **컴포넌트 스캔(Component Scan)** 이다.

또한 스프링은  
**의존관계도 자동으로 주입해주는 기능**을 제공하는데,
이것이 `@Autowired` 이다.

---

## 1. 컴포넌트 스캔 시작하기

기존 `AppConfig` 는 유지하고,
컴포넌트 스캔을 사용하는 새로운 설정 파일을 만든다.

### AutoAppConfig.java
```java
    package hello.core;

    import org.springframework.context.annotation.ComponentScan;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.context.annotation.FilterType;

    import static org.springframework.context.annotation.ComponentScan.*;

    @Configuration
    @ComponentScan(
        excludeFilters = @Filter(
            type = FilterType.ANNOTATION,
            classes = Configuration.class
        )
    )
    public class AutoAppConfig {
        
    }
```
- `@ComponentScan` 을 붙이면 컴포넌트 스캔이 시작된다
- `@Bean` 으로 등록한 클래스가 하나도 없다
- `@Configuration` 이 붙은 기존 설정 클래스(AppConfig 등)는
  컴포넌트 스캔 대상에서 제외했다

> 참고  
> 일반적인 실무에서는 설정 정보를 제외하지 않는다.  
> 여기서는 예제 코드 유지를 위해 제외 필터를 사용했다.

---

## 2. 컴포넌트 스캔의 대상

컴포넌트 스캔은  
`@Component` 가 붙은 클래스를 찾아 스프링 빈으로 등록한다.

다음과 같이 각 클래스에 `@Component` 를 추가한다.

### MemoryMemberRepository
```java
    @Component
    public class MemoryMemberRepository implements MemberRepository {
    
    }
```
### RateDiscountPolicy
```java
    @Component
    public class RateDiscountPolicy implements DiscountPolicy {
    
    }
```
---

## 3. 의존관계 자동 주입 (@Autowired)

이제 설정 정보가 없기 때문에  
의존관계 주입은 클래스 내부에서 해결해야 한다.

### MemberServiceImpl
```java
    @Component
    public class MemberServiceImpl implements MemberService {

        private final MemberRepository memberRepository;

        @Autowired
        public MemberServiceImpl(MemberRepository memberRepository) {
            this.memberRepository = memberRepository;
        }
    }
```

- 생성자에 `@Autowired` 를 붙이면
- 스프링 컨테이너가 타입을 기준으로 빈을 찾아 자동 주입한다

---

### OrderServiceImpl
```java
    @Component
    public class OrderServiceImpl implements OrderService {

        private final MemberRepository memberRepository;
        private final DiscountPolicy discountPolicy;

        @Autowired
        public OrderServiceImpl(
            MemberRepository memberRepository,
            DiscountPolicy discountPolicy
        ) {
            this.memberRepository = memberRepository;
            this.discountPolicy = discountPolicy;
        }
    }
```
- 생성자 파라미터가 여러 개여도
- 모두 자동으로 주입된다

---

## 4. 컴포넌트 스캔 테스트

### AutoAppConfigTest
```java
    package hello.core.scan;

    import hello.core.AutoAppConfig;
    import hello.core.member.MemberService;
    import org.junit.jupiter.api.Test;
    import org.springframework.context.ApplicationContext;
    import org.springframework.context.annotation.AnnotationConfigApplicationContext;

    import static org.assertj.core.api.Assertions.*;

    public class AutoAppConfigTest {

        @Test
        void basicScan() {
            ApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class);

            MemberService memberService = ac.getBean(MemberService.class);
            assertThat(memberService).isInstanceOf(MemberService.class);
        }
    }
```
실행 결과,
기존 `@Bean` 방식과 동일하게 정상 동작한다.

로그를 보면 컴포넌트 스캔 결과도 확인할 수 있다.
```text
    ClassPathBeanDefinitionScanner - Identified candidate component class:
    RateDiscountPolicy
    MemberServiceImpl
    MemoryMemberRepository
    OrderServiceImpl
```
---

## 5. 컴포넌트 스캔 동작 원리

### 5-1. @ComponentScan

- `@Component` 가 붙은 클래스를 모두 스캔
- 스프링 빈으로 자동 등록

#### 빈 이름 기본 전략
- 클래스명 사용
- 첫 글자만 소문자

예)
- `MemberServiceImpl` → `memberServiceImpl`

#### 빈 이름 직접 지정
    @Component("memberService2")

---

### 5-2. @Autowired 자동 주입

- 기본 조회 전략: **타입 기준**
- 내부적으로 `getBean(타입)` 과 동일

즉,

    @Autowired
    MemberRepository memberRepository;

는

    getBean(MemberRepository.class);

과 같은 의미다.

---

## 6. 컴포넌트 스캔 탐색 위치

### basePackages 지정

    @ComponentScan(
        basePackages = "hello.core"
    )

- 지정한 패키지와 하위 패키지를 모두 스캔

### basePackageClasses

    @ComponentScan(
        basePackageClasses = AutoAppConfig.class
    )

- 해당 클래스의 패키지를 시작 위치로 사용

---

### 권장 방법

- 설정 정보 클래스를 **프로젝트 최상단 패키지**에 위치
- `basePackages` 지정 생략

예)

    com.hello
    com.hello.service
    com.hello.repository

이 경우 `com.hello` 아래는 전부 스캔 대상이 된다.

> 스프링 부트의 `@SpringBootApplication` 도  
> 내부에 `@ComponentScan` 이 포함되어 있다.

---

## 7. 컴포넌트 스캔 기본 대상 애노테이션

다음 애노테이션들은 모두 컴포넌트 스캔 대상이다.

- `@Component`
- `@Controller`
- `@Service`
- `@Repository`
- `@Configuration`

이유는 모두 내부에 `@Component` 를 포함하고 있기 때문이다.

---

## 8. 필터 사용하기

### includeFilters / excludeFilters

- `includeFilters` : 스캔 대상 추가
- `excludeFilters` : 스캔 대상 제외

---

### 커스텀 애노테이션 예제

#### 포함 애노테이션

    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    public @interface MyIncludeComponent {
    }

#### 제외 애노테이션

    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    public @interface MyExcludeComponent {
    }

---

### 필터 테스트 설정

    @Configuration
    @ComponentScan(
        includeFilters = @Filter(
            type = FilterType.ANNOTATION,
            classes = MyIncludeComponent.class
        ),
        excludeFilters = @Filter(
            type = FilterType.ANNOTATION,
            classes = MyExcludeComponent.class
        )
    )
    static class ComponentFilterAppConfig {
    }

---

## 9. FilterType 종류

- ANNOTATION (기본값)
- ASSIGNABLE_TYPE
- ASPECTJ
- REGEX
- CUSTOM

---

## 10. 중복 빈 등록과 충돌

### 자동 빈 vs 자동 빈

- 이름이 같으면 오류 발생
- `ConflictingBeanDefinitionException`

---

### 수동 빈 vs 자동 빈

- 수동 빈이 우선권을 가진다
- 자동 빈을 오버라이딩한다

최근 스프링 부트는
이 경우도 **오류를 발생시키도록 기본 설정**이 변경되었다.

    spring.main.allow-bean-definition-overriding=true

이 옵션을 켜야 오버라이딩 가능하다.

---

## 11. 정리

- 컴포넌트 스캔은 반복적인 빈 등록을 제거한다
- `@Autowired` 로 의존관계도 자동 주입된다
- 스프링 부트는 컴포넌트 스캔을 기본 전략으로 사용한다
- 기본 설정을 최대한 유지하는 것이 가장 안전하다

즉,

> **컴포넌트 스캔은  
> 스프링 애플리케이션의 기본 출발점이다**
