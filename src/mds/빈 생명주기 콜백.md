# 📦 빈 생명주기 콜백 (Bean Lifecycle Callback)

스프링 빈은 단순히 생성되고 끝나는 객체가 아니다.  
애플리케이션 시작과 종료 시점에 **초기화 작업**과 **정리 작업**이 필요한 경우가 많다.

대표적인 예:
- 데이터베이스 커넥션 풀 초기화 / 종료
- 네트워크 소켓 연결 / 해제
- 외부 시스템 연동 리소스 관리

스프링은 이러한 작업을 안전하게 처리할 수 있도록  
**빈 생명주기 콜백 메커니즘**을 제공한다.

> **콜백(callback)**  
> 내가 직접 호출하지 않았는데,  
> **특정 시점에 프레임워크가 대신 호출해주는 메서드**

---

## 🧠 직관적 비유: “신축 아파트 입주 가전”

- **객체 생성**: 가전제품(빈)이 집에 배달됨 (메모리 할당)
- **의존관계 주입**: 전원 코드와 인터넷 선을 벽에 꽂음
- **초기화 콜백**: 전원이 들어온 후 서버에 접속해 초기 세팅
- **소멸 콜백**: 이사 전 로그아웃하고 안전하게 종료

👉 **전원이 꽂히기 전에는 가전을 켜면 안 된다**

---

## 1️⃣ 빈 생명주기 콜백이 필요한 이유

### 가정 상황
- 애플리케이션 시작 시 외부 서버에 미리 연결
- 애플리케이션 종료 시 연결 해제

이를 위해 객체에는 다음이 필요하다.
- 초기화(init) 작업
- 종료(destroy) 작업

### 핵심
👉 **객체의 생성과 초기화를 분리해야 한다**

| 구분 | 역할 |
|---|---|
| 생성자 | 메모리 할당, 필수 값 설정 |
| 초기화 | 외부 리소스 연결 |
| 종료 | 리소스 해제 |

---

## 2️⃣ 생성자에서 초기화하면 안 되는 이유

### ❌ 문제 코드

```java
package hello.core.lifecycle;

public class NetworkClient {

    private String url;

    public NetworkClient() {
        System.out.println("생성자 호출, url = " + url);
        connect();
        call("초기화 연결 메시지");
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public void connect() {
        System.out.println("connect: " + url);
    }

    public void call(String message) {
        System.out.println("call: " + url + " message = " + message);
    }

    public void disconnect() {
        System.out.println("close: " + url);
    }
}
```

### 실행 결과

```
생성자 호출, url = null
connect: null
call: null message = 초기화 연결 메시지
```

### 문제 원인
- 생성자 호출 시점에는 **의존관계 주입이 완료되지 않음**
- `url`은 `setUrl()` 호출 이후에 설정됨
- 생성자에서 초기화 → **null 상태로 동작**

👉 **초기화 로직은 반드시 의존관계 주입 이후에 실행해야 한다**

---

## 3️⃣ 스프링 빈 생명주기

```
스프링 컨테이너 생성
→ 스프링 빈 생성
→ 의존관계 주입
→ 초기화 콜백
→ 사용
→ 소멸 전 콜백
→ 스프링 컨테이너 종료
```

### 핵심 포인트
- 초기화 콜백은 **주입 완료 후**
- 소멸 콜백은 **컨테이너 종료 직전**

---

## 4️⃣ 객체 생성과 초기화는 분리하자 (중요)

### 권장 원칙
- 생성자: 필수 값, 객체 상태 보장
- 초기화 메서드: 외부 리소스 연결, 무거운 작업

### 장점
- 설계 명확
- 테스트 용이
- 유지보수성 향상

---

## 5️⃣ 스프링이 제공하는 생명주기 콜백 방법 (3가지)

1️⃣ 인터페이스 방식 (`InitializingBean`, `DisposableBean`)  
2️⃣ `@Bean(initMethod, destroyMethod)`  
3️⃣ `@PostConstruct`, `@PreDestroy` ⭐

---

## 6️⃣ 인터페이스 방식 (비권장)

```java
package hello.core.lifecycle;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.DisposableBean;

public class NetworkClient implements InitializingBean, DisposableBean {

    private String url;

    public NetworkClient() {
        System.out.println("생성자 호출, url = " + url);
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public void connect() {
        System.out.println("connect: " + url);
    }

    public void call(String message) {
        System.out.println("call: " + url + " message = " + message);
    }

    public void disConnect() {
        System.out.println("close + " + url);
    }

    @Override
    public void afterPropertiesSet() {
        connect();
        call("초기화 연결 메시지");
    }

    @Override
    public void destroy() {
        disConnect();
    }
}
```

### 단점
- 스프링 인터페이스 의존
- 메서드 이름 변경 불가
- 외부 라이브러리에 적용 불가

---

## 7️⃣ @Bean으로 초기화 / 소멸 메서드 지정

### NetworkClient

```java
public class NetworkClient {

    private String url;

    public NetworkClient() {
        System.out.println("생성자 호출, url = " + url);
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public void connect() {
        System.out.println("connect: " + url);
    }

    public void call(String message) {
        System.out.println("call: " + url + " message = " + message);
    }

    public void disConnect() {
        System.out.println("close + " + url);
    }

    public void init() {
        System.out.println("NetworkClient.init");
        connect();
        call("초기화 연결 메시지");
    }

    public void close() {
        System.out.println("NetworkClient.close");
        disConnect();
    }
}
```

### 설정 정보

```java
@Configuration
static class LifeCycleConfig {

    @Bean(initMethod = "init", destroyMethod = "close")
    public NetworkClient networkClient() {
        NetworkClient networkClient = new NetworkClient();
        networkClient.setUrl("http://hello-spring.dev");
        return networkClient;
    }
}
```

---

## 8️⃣ 종료 메서드 추론 기능

- 기본값: `(inferred)`
- 자동 탐색 메서드:
    - `close`
    - `shutdown`

### 비활성화

```java
@Bean(destroyMethod = "")
```

---

## 9️⃣ @PostConstruct / @PreDestroy (최신 권장)

```java
package hello.core.lifecycle;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

public class NetworkClient {

    private String url;

    public NetworkClient() {
        System.out.println("생성자 호출, url = " + url);
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public void connect() {
        System.out.println("connect: " + url);
    }

    public void call(String message) {
        System.out.println("call: " + url + " message = " + message);
    }

    public void disConnect() {
        System.out.println("close + " + url);
    }

    @PostConstruct
    public void init() {
        System.out.println("NetworkClient.init");
        connect();
        call("초기화 연결 메시지");
    }

    @PreDestroy
    public void close() {
        System.out.println("NetworkClient.close");
        disConnect();
    }
}
```

---

## 🔚 최종 정리

### 권장 우선순위
1️⃣ `@PostConstruct`, `@PreDestroy`  
2️⃣ `@Bean(initMethod, destroyMethod)`  
3️⃣ 인터페이스 방식 (비권장)

### 핵심 요약
> **생성자에서 초기화하지 말고  
> 의존관계 주입 이후에 초기화하자**

👉 실무에서는 거의 항상  
**`@PostConstruct`, `@PreDestroy`를 사용한다**
