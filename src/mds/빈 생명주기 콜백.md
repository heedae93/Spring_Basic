# 📦 빈 생명주기 콜백 (Bean Lifecycle Callback)

스프링 빈은 단순히 생성되고 끝나는 객체가 아니다.  
애플리케이션 시작과 종료 시점에 **초기화 작업**과 **정리 작업**이 필요한 경우가 많다.

대표적인 예:
- 데이터베이스 커넥션 풀 초기화 / 종료
- 네트워크 소켓 연결 / 해제
- 외부 시스템 연동 리소스 관리

스프링은 이러한 작업을 안전하게 처리할 수 있도록  
**빈 생명주기 콜백 메커니즘**을 제공한다.

> **콜백(callback)**  
> 내가 직접 호출하지 않았는데,  
> **특정 시점에 프레임워크가 대신 호출해주는 메서드**

---

## 🧠 직관적 비유: “신축 아파트 입주 가전”

- **객체 생성**: 가전제품(빈)이 집에 배달됨 (메모리 할당)
- **의존관계 주입**: 전원 코드와 인터넷 선을 벽에 꽂음
- **초기화 콜백**: 전원이 들어온 후 서버에 접속해 초기 세팅
- **소멸 콜백**: 이사 전 로그아웃하고 안전하게 종료

👉 **전원이 꽂히기 전에는 가전을 켜면 안 된다**

---

## 1️⃣ 빈 생명주기 콜백이 필요한 이유

### 가정 상황
- 애플리케이션 시작 시 외부 서버에 미리 연결
- 애플리케이션 종료 시 연결 해제

이를 위해 객체에는 다음이 필요하다.
- 초기화(init) 작업
- 종료(destroy) 작업

### 핵심
👉 **객체의 생성과 초기화를 분리해야 한다**

| 구분 | 역할 |
|---|---|
| 생성자 | 메모리 할당, 필수 값 설정 |
| 초기화 | 외부 리소스 연결 |
| 종료 | 리소스 해제 |

---

## 2️⃣ 생성자에서 초기화하면 안 되는 이유

### ❌ 문제 코드

```java
package hello.core.lifecycle;

public class NetworkClient {

    private String url;

    public NetworkClient() {
        System.out.println("생성자 호출, url = " + url);
        connect();
        call("초기화 연결 메시지");
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public void connect() {
        System.out.println("connect: " + url);
    }

    public void call(String message) {
        System.out.println("call: " + url + " message = " + message);
    }

    public void disconnect() {
        System.out.println("close: " + url);
    }
}
```

### 실행 결과

```
생성자 호출, url = null
connect: null
call: null message = 초기화 연결 메시지
```

### 문제 원인
- 생성자 호출 시점에는 **의존관계 주입이 완료되지 않음**
- `url`은 `setUrl()` 호출 이후에 설정됨
- 생성자에서 초기화 → **null 상태로 동작**

👉 **초기화 로직은 반드시 의존관계 주입 이후에 실행해야 한다**

---

## 3️⃣ 스프링 빈 생명주기

```
스프링 컨테이너 생성
→ 스프링 빈 생성
→ 의존관계 주입
→ 초기화 콜백
→ 사용
→ 소멸 전 콜백
→ 스프링 컨테이너 종료
```

### 핵심 포인트
- 초기화 콜백은 **주입 완료 후**
- 소멸 콜백은 **컨테이너 종료 직전**

---

## 4️⃣ 객체 생성과 초기화는 분리하자 (중요)

### 권장 원칙
- 생성자: 필수 값, 객체 상태 보장
- 초기화 메서드: 외부 리소스 연결, 무거운 작업

### 장점
- 설계 명확
- 테스트 용이
- 유지보수성 향상

---

## 5️⃣ 스프링이 제공하는 생명주기 콜백 방법 (3가지)

1️⃣ 인터페이스 방식 (`InitializingBean`, `DisposableBean`)  
2️⃣ `@Bean(initMethod, destroyMethod)`  
3️⃣ `@PostConstruct`, `@PreDestroy` ⭐

---

## 6️⃣ 인터페이스 방식 (비권장)

```java
package hello.core.lifecycle;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.DisposableBean;

public class NetworkClient implements InitializingBean, DisposableBean {

    private String url;

    public NetworkClient() {
        System.out.println("생성자 호출, url = " + url);
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public void connect() {
        System.out.println("connect: " + url);
    }

    public void call(String message) {
        System.out.println("call: " + url + " message = " + message);
    }

    public void disConnect() {
        System.out.println("close + " + url);
    }

    @Override
    public void afterPropertiesSet() {
        connect();
        call("초기화 연결 메시지");
    }

    @Override
    public void destroy() {
        disConnect();
    }
}
```

### 단점
- 스프링 인터페이스 의존
- 메서드 이름 변경 불가
- 외부 라이브러리에 적용 불가

---

## 7️⃣ @Bean으로 초기화 / 소멸 메서드 지정

### NetworkClient

```java
public class NetworkClient {

    private String url;

    public NetworkClient() {
        System.out.println("생성자 호출, url = " + url);
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public void connect() {
        System.out.println("connect: " + url);
    }

    public void call(String message) {
        System.out.println("call: " + url + " message = " + message);
    }

    public void disConnect() {
        System.out.println("close + " + url);
    }

    public void init() {
        System.out.println("NetworkClient.init");
        connect();
        call("초기화 연결 메시지");
    }

    public void close() {
        System.out.println("NetworkClient.close");
        disConnect();
    }
}
```

### 설정 정보

```java
@Configuration
static class LifeCycleConfig {

    @Bean(initMethod = "init", destroyMethod = "close")
    public NetworkClient networkClient() {
        NetworkClient networkClient = new NetworkClient();
        networkClient.setUrl("http://hello-spring.dev");
        return networkClient;
    }
}
```

---

## 8️⃣ 종료 메서드 추론 기능

- 기본값: `(inferred)`
- 자동 탐색 메서드:
    - `close`
    - `shutdown`

### 비활성화

```java
@Bean(destroyMethod = "")
```

---

## 9️⃣ @PostConstruct / @PreDestroy (최신 권장)

```java
package hello.core.lifecycle;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

public class NetworkClient {

    private String url;

    public NetworkClient() {
        System.out.println("생성자 호출, url = " + url);
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public void connect() {
        System.out.println("connect: " + url);
    }

    public void call(String message) {
        System.out.println("call: " + url + " message = " + message);
    }

    public void disConnect() {
        System.out.println("close + " + url);
    }

    @PostConstruct
    public void init() {
        System.out.println("NetworkClient.init");
        connect();
        call("초기화 연결 메시지");
    }

    @PreDestroy
    public void close() {
        System.out.println("NetworkClient.close");
        disConnect();
    }
}
```

---


---

## 🔟 실제 DB 커넥션 예제로 보는 생명주기 콜백 (실무 예제)

지금까지는 네트워크 예제로 생명주기를 봤다면,  
이번에는 **실무에서 가장 흔한 DB 커넥션 예제**로 살펴본다.

### 목표 시나리오
- 애플리케이션 시작 시 → DB 커넥션 연결
- 애플리케이션 종료 시 → DB 커넥션 해제
- 생성자에서는 **절대 DB 연결하지 않음**

---

## 🔟-1️⃣ DB 커넥션을 담당하는 순수 자바 클래스

> ✔ 스프링에 의존하지 않는 POJO  
> ✔ 생성자에서는 값만 받고, 실제 연결은 init 단계에서 수행

```java
package example.db;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DbConnectionManager {

    private Connection connection;

    private final String url;
    private final String username;
    private final String password;

    public DbConnectionManager(String url, String username, String password) {
        // 생성자: 값만 보관 (절대 DB 연결 X)
        this.url = url;
        this.username = username;
        this.password = password;
        System.out.println("DbConnectionManager 생성자 호출");
    }

    public void connect() {
        try {
            System.out.println("DB 연결 시도");
            this.connection =
                    DriverManager.getConnection(url, username, password);
            System.out.println("DB 연결 성공");
        } catch (SQLException e) {
            throw new IllegalStateException("DB 연결 실패", e);
        }
    }

    public Connection getConnection() {
        return connection;
    }

    public void disconnect() {
        if (connection != null) {
            try {
                System.out.println("DB 연결 종료");
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```

---

## 🔟-2️⃣ @PostConstruct / @PreDestroy로 콜백 지정 (권장)

### ✔ 콜백은 **어디에 지정하는가?**
👉 **빈 클래스 내부 메서드에 애노테이션으로 지정**

```java
package example.db;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DbConnectionManager {

    private Connection connection;

    private final String url;
    private final String username;
    private final String password;

    public DbConnectionManager(String url, String username, String password) {
        this.url = url;
        this.username = username;
        this.password = password;
        System.out.println("생성자 호출");
    }

    @PostConstruct
    public void init() {
        // 🔥 스프링이 대신 호출
        System.out.println("@PostConstruct 호출");
        connect();
    }

    @PreDestroy
    public void close() {
        // 🔥 스프링이 대신 호출
        System.out.println("@PreDestroy 호출");
        disconnect();
    }

    private void connect() {
        try {
            connection =
                DriverManager.getConnection(url, username, password);
            System.out.println("DB 연결 완료");
        } catch (SQLException e) {
            throw new IllegalStateException(e);
        }
    }

    private void disconnect() {
        try {
            if (connection != null) {
                connection.close();
                System.out.println("DB 연결 종료");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

---

## 🔟-3️⃣ 이 객체를 빈으로 등록하는 설정 클래스

> ✔ **여기서는 콜백을 지정하지 않는다**  
> ✔ 콜백은 이미 클래스 내부에 선언되어 있음

```java
package example.config;

import example.db.DbConnectionManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class DbConfig {

    @Bean
    public DbConnectionManager dbConnectionManager() {
        return new DbConnectionManager(
            "jdbc:mysql://localhost:3306/testdb",
            "root",
            "1234"
        );
    }
}
```

---

## 🔟-4️⃣ 실제 실행 시 호출 순서 (매우 중요 ⭐)

```
1. 스프링 컨테이너 시작
2. DbConnectionManager 생성자 호출
3. 의존관계 주입 완료
4. @PostConstruct 메서드 호출  ← 스프링
   → DB 커넥션 연결
5. 애플리케이션 정상 동작
6. 스프링 컨테이너 종료
7. @PreDestroy 메서드 호출    ← 스프링
   → DB 커넥션 종료
```

👉 `init()`, `close()`는  
❌ 개발자가 직접 호출하지 않는다  
✅ **스프링 컨테이너가 자동으로 호출**

---

## 🔟-5️⃣ @Bean(initMethod, destroyMethod) 방식 (외부 라이브러리 예제)

### 외부 라이브러리라고 가정한 클래스

```java
public class ExternalDbClient {

    public void start() {
        System.out.println("외부 DB 연결");
    }

    public void shutdown() {
        System.out.println("외부 DB 연결 종료");
    }
}
```

---

### 설정 클래스에서 콜백 지정

```java
@Configuration
public class ExternalDbConfig {

    @Bean(initMethod = "start", destroyMethod = "shutdown")
    public ExternalDbClient externalDbClient() {
        return new ExternalDbClient();
    }
}
```

### 핵심 차이

| 구분 | @PostConstruct | @Bean(initMethod) |
|---|---|---|
| 콜백 위치 | 클래스 내부 | 설정 클래스 |
| 외부 라이브러리 | ❌ | ⭕ |
| 권장도 | ⭐⭐⭐ | ⭐⭐ |

---

## 🔟-6️⃣ 핵심 정리 (DB 예제 기준)

- DB 커넥션은 **생성자에서 열지 않는다**
- 생명주기 콜백에서 연결/해제한다
- init / destroy 메서드는  
  **스프링 컨테이너가 호출한다**
- 실무에서는 거의 항상  
  `@PostConstruct`, `@PreDestroy` 사용

> **외부 리소스(DB, 소켓, 파일)는  
> 객체 생명주기에 맞춰 관리해야 한다**


## 🔚 최종 정리

### 권장 우선순위
1️⃣ `@PostConstruct`, `@PreDestroy`  
2️⃣ `@Bean(initMethod, destroyMethod)`  
3️⃣ 인터페이스 방식 (비권장)

### 핵심 요약
> **생성자에서 초기화하지 말고  
> 의존관계 주입 이후에 초기화하자**

👉 실무에서는 거의 항상  
**`@PostConstruct`, `@PreDestroy`를 사용한다**
