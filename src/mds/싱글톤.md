# 싱글톤 컨테이너의 필요성

## 1. 스프링 없는 순수한 DI 컨테이너의 문제점
기존에 작성한 `AppConfig`는 의존관계 주입(DI)을 도와주는 설정 파일이다. 하지만 스프링 컨테이너 없이 자바 코드만으로(`new AppConfig()`) 사용하면 객체 생성 제어가 불가능하다는 단점이 있다.

### 문제의 코드 (AppConfig.java)

    @Configuration
    public class AppConfig {

        @Bean
        public MemberService memberService() {
            return new MemberServiceImpl(memberRepository());
        }

        @Bean
        public MemberRepository memberRepository() {
            return new MemoryMemberRepository();
        }

        @Bean
        public OrderService orderService() {
            return new OrderServiceImpl(memberRepository(), discountPolicy());
        }

        @Bean
        public DiscountPolicy discountPolicy() {
            return new FixDiscountPolicy();
        }
    }

### 테스트 코드를 통한 문제 확인
순수 자바 환경에서 `new AppConfig()`를 생성하여 객체를 조회해 본다. 이 경우 `@Configuration`이나 `@Bean` 어노테이션은 동작하지 않으며, 단순히 자바 클래스의 메서드를 호출하게 된다.



    @Test
    @DisplayName("스프링 없는 순수한 di 컨테이너")
    void pureContainer() {
        AppConfig appConfig = new AppConfig();

        // 1. 조회: 호출할 때마다 객체를 생성
        MemberService memberService1 = appConfig.memberService();

        // 2. 조회: 호출할 때마다 객체를 생성
        MemberService memberService2 = appConfig.memberService();

        // 3. 참조값이 다른 것을 확인
        System.out.println("memberService1 = " + memberService1); 
        System.out.println("memberService2 = " + memberService2); 

        // 호출할 때마다 새로운 객체가 생성되므로 참조값이 다르다 (isNotSameAs)
        Assertions.assertThat(memberService1).isNotSameAs(memberService2);
    }

## 2. 발생 원인과 한계
1. **자바 코드의 정직한 실행**: `new AppConfig()`는 일반 자바 객체를 생성하는 행위다. 메서드가 호출될 때마다 코드에 명시된 `new` 로직이 매번 실행된다.
2. **메모리 낭비**: 고객의 요청이 올 때마다 객체를 새로 생성하게 된다. 초당 100건의 트래픽이 발생하면 매초 수많은 객체가 생성되고 소멸되어 가비지 컬렉터(GC)에 과도한 부하를 준다.
3. **싱글톤 보장 불가**: 자바 코드만으로는 특정 클래스의 인스턴스를 하나만 생성하여 공유하는 '싱글톤' 구조를 강제하기 어렵다.

## 3. 해결 방안: 스프링 싱글톤 컨테이너
이러한 문제를 해결하기 위해 스프링 컨테이너를 사용해야 한다.

* **스프링 컨테이너 적용**: 스프링은 `@Configuration`이 붙은 `AppConfig`를 상속받은 가짜 프록시 객체(CGLIB)를 만든다. 이 프록시 객체는 메서드가 호출될 때 이미 컨테이너에 등록된 빈이 있다면 그 객체를 찾아 반환함으로써 싱글톤을 보장한다.
* **결과**: 수많은 클라이언트 요청이 있어도 이미 생성된 단 하나의 객체를 공유하여 메모리를 효율적으로 사용하고 성능 최적화를 이룰 수 있다.

### 싱글톤 패턴 적용 코드 (SingleToneService.java)

    public class SingleToneService {

        // 1. static 영역에 객체를 딱 1개만 생성한다.
        private static final SingleToneService instance = new SingleToneService();

        // 2. public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용한다.
        // 이 메서드를 호출하면 항상 같은 인스턴스를 반환한다.
        public static SingleToneService getInstance() {
            return instance;
        }

        // 3. 생성자를 private으로 선언해서 외부에서 new 키워드를 사용한 객체 생성을 못하게 막는다.
        private SingleToneService() {
        }

        public void logic() {
            System.out.println("싱글톤 객체 로직 호출");
        }
    }



### 테스트 코드를 통한 싱글톤 확인

    @Test
    @DisplayName("싱글톤 패턴을 적용한 객체 사용")
    void singletonServiceTest() {

        // private으로 생성자를 막아두었기에 new 키워드로 생성이 불가하다.
        // 오직 getInstance() 메서드를 통해서만 객체를 조회할 수 있다.
        SingleToneService singleToneService1 = SingleToneService.getInstance();
        SingleToneService singleToneService2 = SingleToneService.getInstance();

        // 참조값이 같은 것을 확인한다.
        System.out.println("singleToneService1 = " + singleToneService1);
        System.out.println("singleToneService2 = " + singleToneService2);

        // singleToneService1 == singleToneService2
        Assertions.assertThat(singleToneService1).isSameAs(singleToneService2);
    }

## 3. 싱글톤 패턴의 문제점
싱글톤 패턴을 직접 구현하면 여러 가지 단점이 존재한다.
1. 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
2. 의존관계상 클라이언트가 구체 클래스에 의존하게 되어 DIP를 위반한다.
3. 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
4. 테스트하기 어렵고 내부 상태를 초기화하거나 변경하기 어렵다.
5. private 생성자로 인해 자식 클래스를 만들기 어려워 유연성이 떨어진다.

## 4. 스프링의 싱글톤 컨테이너
스프링 컨테이너는 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 관리한다.

* **싱글톤 레지스트리**: 스프링 컨테이너는 싱글톤 패턴을 위한 지저분한 코드를 작성하지 않아도 객체를 하나만 생성해서 관리한다.
* **DIP, OCP 준수**: 스프링 컨테이너 덕분에 클라이언트 코드는 구체 클래스가 아닌 인터페이스에 의존할 수 있으며, 싱글톤을 유지하면서도 자유롭게 객체를 주입할 수 있다.
* **결과**: 스프링을 사용하면 이미 싱글톤 패턴이 적용된 효율적인 객체 관리 환경을 기본으로 제공받는다.
