# 싱글톤 컨테이너의 필요성

## 1. 스프링 없는 순수한 DI 컨테이너의 문제점
기존에 작성한 `AppConfig`는 의존관계 주입(DI)을 도와주는 설정 파일이다. 하지만 스프링 컨테이너 없이 자바 코드만으로(`new AppConfig()`) 사용하면 객체 생성 제어가 불가능하다는 단점이 있다.

### 문제의 코드 (AppConfig.java)
```java
    @Configuration
    public class AppConfig {

        @Bean
        public MemberService memberService() {
            return new MemberServiceImpl(memberRepository());
        }

        @Bean
        public MemberRepository memberRepository() {
            return new MemoryMemberRepository();
        }

        @Bean
        public OrderService orderService() {
            return new OrderServiceImpl(memberRepository(), discountPolicy());
        }

        @Bean
        public DiscountPolicy discountPolicy() {
            return new FixDiscountPolicy();
        }
    }
```
### 테스트 코드를 통한 문제 확인
순수 자바 환경에서 `new AppConfig()`를 생성하여 객체를 조회해 본다. 이 경우 `@Configuration`이나 `@Bean` 어노테이션은 동작하지 않으며, 단순히 자바 클래스의 메서드를 호출하게 된다.


```java
    @Test
    @DisplayName("스프링 없는 순수한 di 컨테이너")
    void pureContainer() {
        AppConfig appConfig = new AppConfig();

        // 1. 조회: 호출할 때마다 객체를 생성
        MemberService memberService1 = appConfig.memberService();

        // 2. 조회: 호출할 때마다 객체를 생성
        MemberService memberService2 = appConfig.memberService();

        // 3. 참조값이 다른 것을 확인
        System.out.println("memberService1 = " + memberService1); 
        System.out.println("memberService2 = " + memberService2); 

        // 호출할 때마다 새로운 객체가 생성되므로 참조값이 다르다 (isNotSameAs)
        Assertions.assertThat(memberService1).isNotSameAs(memberService2);
    }
```
## 2. 발생 원인과 한계
1. **자바 코드의 정직한 실행**: `new AppConfig()`는 일반 자바 객체를 생성하는 행위다. 메서드가 호출될 때마다 코드에 명시된 `new` 로직이 매번 실행된다.
2. **메모리 낭비**: 고객의 요청이 올 때마다 객체를 새로 생성하게 된다. 초당 100건의 트래픽이 발생하면 매초 수많은 객체가 생성되고 소멸되어 가비지 컬렉터(GC)에 과도한 부하를 준다.
3. **싱글톤 보장 불가**: 자바 코드만으로는 특정 클래스의 인스턴스를 하나만 생성하여 공유하는 '싱글톤' 구조를 강제하기 어렵다.

## 3. 해결 방안: 스프링 싱글톤 컨테이너
이러한 문제를 해결하기 위해 스프링 컨테이너를 사용해야 한다.

* **스프링 컨테이너 적용**: 스프링은 `@Configuration`이 붙은 `AppConfig`를 상속받은 가짜 프록시 객체(CGLIB)를 만든다. 이 프록시 객체는 메서드가 호출될 때 이미 컨테이너에 등록된 빈이 있다면 그 객체를 찾아 반환함으로써 싱글톤을 보장한다.
* **결과**: 수많은 클라이언트 요청이 있어도 이미 생성된 단 하나의 객체를 공유하여 메모리를 효율적으로 사용하고 성능 최적화를 이룰 수 있다.

### 싱글톤 패턴 적용 코드 (SingleToneService.java)

```java
    public class SingleToneService {

        // 1. static 영역에 객체를 딱 1개만 생성한다.
        private static final SingleToneService instance = new SingleToneService();

        // 2. public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용한다.
        // 이 메서드를 호출하면 항상 같은 인스턴스를 반환한다.
        public static SingleToneService getInstance() {
            return instance;
        }

        // 3. 생성자를 private으로 선언해서 외부에서 new 키워드를 사용한 객체 생성을 못하게 막는다.
        private SingleToneService() {
        }

        public void logic() {
            System.out.println("싱글톤 객체 로직 호출");
        }
    }
```


### 테스트 코드를 통한 싱글톤 확인
```java
    @Test
    @DisplayName("싱글톤 패턴을 적용한 객체 사용")
    void singletonServiceTest() {

        // private으로 생성자를 막아두었기에 new 키워드로 생성이 불가하다.
        // 오직 getInstance() 메서드를 통해서만 객체를 조회할 수 있다.
        SingleToneService singleToneService1 = SingleToneService.getInstance();
        SingleToneService singleToneService2 = SingleToneService.getInstance();

        // 참조값이 같은 것을 확인한다.
        System.out.println("singleToneService1 = " + singleToneService1);
        System.out.println("singleToneService2 = " + singleToneService2);

        // singleToneService1 == singleToneService2
        Assertions.assertThat(singleToneService1).isSameAs(singleToneService2);
    }
```
## 3. 싱글톤 패턴의 문제점
싱글톤 패턴을 직접 구현하면 여러 가지 단점이 존재한다.
1. 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
2. 의존관계상 클라이언트가 구체 클래스에 의존하게 되어 DIP를 위반한다.
3. 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
4. 테스트하기 어렵고 내부 상태를 초기화하거나 변경하기 어렵다.
5. private 생성자로 인해 자식 클래스를 만들기 어려워 유연성이 떨어진다.

## 4. 스프링의 싱글톤 컨테이너
스프링 컨테이너는 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 관리한다.

* **싱글톤 레지스트리**: 스프링 컨테이너는 싱글톤 패턴을 위한 지저분한 코드를 작성하지 않아도 객체를 하나만 생성해서 관리한다.
* **DIP, OCP 준수**: 스프링 컨테이너 덕분에 클라이언트 코드는 구체 클래스가 아닌 인터페이스에 의존할 수 있으며, 싱글톤을 유지하면서도 자유롭게 객체를 주입할 수 있다.
* **결과**: 스프링을 사용하면 이미 싱글톤 패턴이 적용된 효율적인 객체 관리 환경을 기본으로 제공받는다.

## 5. 스프링 컨테이너를 통한 싱글톤 구현

앞에서 살펴본 것처럼,
순수 자바 DI 컨테이너는 객체를 호출할 때마다 새로 생성하는 문제가 있었다.
이를 해결하기 위해 전통적인 싱글톤 패턴을 직접 구현할 수 있지만,
그 방식에는 여러 구조적인 단점이 존재했다.

이제 스프링 컨테이너가
**어떻게 싱글톤을 보장하는지**와
**기존 싱글톤 패턴의 단점을 어떻게 해결하는지**
를 이어서 살펴본다.

---

### 5-1. 스프링 컨테이너에서 싱글톤 확인 테스트

다음 테스트 코드는 스프링 컨테이너를 사용했을 때
같은 빈이 항상 동일한 인스턴스로 반환되는지를 확인한다.
```java
    @Test
    @DisplayName("스프링 컨테이너와 싱글톤")
    void springContainer() {

        AnnotationConfigApplicationContext ac =
                new AnnotationConfigApplicationContext(AppConfig.class);

        MemberService memberService1 =
                ac.getBean("memberService", MemberService.class);

        MemberService memberService2 =
                ac.getBean("memberService", MemberService.class);

        System.out.println("memberService1 = " + memberService1);
        System.out.println("memberService2 = " + memberService2);

        Assertions.assertThat(memberService1).isSameAs(memberService2);
    }
```
테스트 결과:
- 두 번 조회한 `memberService`의 참조값이 동일하다
- 즉, **스프링 컨테이너는 동일한 빈을 하나만 생성하여 공유한다**

---

### 5-2. 스프링 컨테이너에서는 무엇이 달라졌는가?

#### 순수 자바 DI 컨테이너
- `new AppConfig()` 호출
- 메서드 호출 시마다 `new` 실행
- 객체가 계속 새로 생성됨

#### 스프링 컨테이너
- `AnnotationConfigApplicationContext`가 AppConfig를 관리
- 애플리케이션 시작 시 빈을 미리 생성
- 동일한 빈 요청 시 이미 생성된 객체 반환

즉,

> **객체 생성의 주도권이 개발자가 아닌 스프링 컨테이너로 이동했다**

---

### 5-3. 싱글톤이 보장되는 핵심 원리

#### ① 빈 등록 단계

스프링 컨테이너는 애플리케이션 시작 시 다음 작업을 수행한다.

1. `@Configuration`이 붙은 AppConfig를 설정 정보로 인식
2. `@Bean` 메서드들을 분석
3. 반환 객체를 빈으로 생성
4. 빈 이름을 키로 하여 컨테이너 내부에 저장

이 과정에서 `memberService`는 **단 한 번만 생성**된다.

---

#### ② 빈 조회 단계

    ac.getBean("memberService", MemberService.class);

- 컨테이너 내부의 싱글톤 레지스트리에서
- 이미 생성된 `memberService` 인스턴스를 반환

👉 **새 객체 생성 없음**

---

### 5-4. @Configuration의 역할 (아주 중요)

`@Configuration`이 붙은 클래스는
스프링이 **CGLIB 기반의 프록시 객체**로 감싼다.

이 프록시의 역할은 다음과 같다.

- `@Bean` 메서드가 호출될 때
- 이미 생성된 빈이 있는지 먼저 확인
- 있다면 기존 객체 반환
- 없다면 새로 생성 후 등록

즉,

> @Bean 메서드를 여러 번 호출해도  
> 실제 객체는 한 번만 생성된다

이 때문에 **싱글톤이 깨지지 않는다.**

---

### 5-5. 전통적인 싱글톤 패턴과의 차이

#### 기존 싱글톤 패턴
```java
    public class SingletonService {
        private static final SingletonService instance = new SingletonService();
        private SingletonService() {}
        public static SingletonService getInstance() {
            return instance;
        }
    }
```
문제점:
- 구현 코드가 복잡함
- 구체 클래스에 직접 의존 (DIP 위반)
- 테스트 어려움
- 상속 및 확장 불가
- 유연성 저하

---

#### 스프링 컨테이너 기반 싱글톤

- static 코드 ❌
- private 생성자 ❌
- 인터페이스 기반 주입 ⭕
- 테스트 용이 ⭕
- 확장 가능 ⭕

즉,

> **싱글톤 패턴의 장점만 취하고 단점은 제거**

---

### 5-6. 싱글톤 패턴의 단점은 어떻게 개선되었는가?

- 싱글톤 구현 코드 제거 → 코드 단순화
- 인터페이스 기반 설계 → DIP, OCP 준수
- 테스트 시 자유로운 객체 교체 가능
- 프록시, AOP 등 스프링 기능과 자연스럽게 결합

---

### 5-7. 정리

- 스프링 컨테이너는 기본적으로 싱글톤 스코프를 사용한다
- 객체는 애플리케이션 전체에서 하나만 생성되어 공유된다
- 개발자가 싱글톤 패턴을 직접 구현할 필요가 없다
- 싱글톤 패턴의 모든 단점을 스프링 컨테이너가 해결한다

즉,

> **스프링 컨테이너는  
> 싱글톤 패턴을 가장 안전하고 유연하게 구현한 환경이다**

## 6. 싱글톤 방식 사용 시 주의점 (무상태 설계)

싱글톤 패턴이든, 스프링과 같은 싱글톤 컨테이너를 사용하든  
**객체 인스턴스를 하나만 생성해서 여러 클라이언트가 공유하는 방식**에는
반드시 지켜야 할 중요한 원칙이 있다.

### 핵심 원칙

> **싱글톤 객체는 상태(state)를 가지면 안 된다.  
> 반드시 무상태(stateless)로 설계해야 한다.**

---

### 6-1. 왜 싱글톤 객체는 무상태여야 하는가?

싱글톤 객체는:
- 애플리케이션 전체에서 **단 하나의 인스턴스만 존재**
- 여러 클라이언트(여러 사용자, 여러 스레드)가 **동시에 공유**

따라서 다음과 같은 설계는 매우 위험하다.

- 특정 클라이언트에 의존적인 필드를 가진 경우
- 특정 클라이언트가 값을 변경할 수 있는 필드를 가진 경우
- 필드에 요청 결과나 중간 상태를 저장하는 경우

이런 상태를 가지게 되면,
**다른 사용자의 요청 결과가 섞이는 심각한 장애**가 발생할 수 있다.

---

### 6-2. 싱글톤 객체 설계 시 지켜야 할 규칙

- 특정 클라이언트에 의존적인 필드 ❌
- 특정 클라이언트가 값을 변경할 수 있는 필드 ❌
- 가급적 읽기만 가능한 구조 ⭕
- 필드 대신 지역 변수, 파라미터 사용 ⭕
- 필요 시 ThreadLocal 사용 ⭕

👉 **스프링 빈의 필드에 공유 값을 저장하면 큰 장애로 이어질 수 있다.**

---

### 6-3. 상태를 유지할 경우 발생하는 문제 예시

다음 코드는 싱글톤 객체에 상태를 저장했을 때 발생하는 전형적인 문제 예시다.

#### 문제의 코드 (StatefulService)
```java
    package hello.core.singleton;

    public class StatefulService {

        private int price; // 상태를 유지하는 필드 (문제의 원인)

        public void order(String name, int price) {
            System.out.println("name = " + name + " price = " + price);
            this.price = price; // 여기서 상태가 변경된다
        }

        public int getPrice() {
            return price;
        }
    }
```

---

### 6-4. 상태 공유로 인한 문제 확인 테스트
```java
    package hello.core.singleton;

    import org.assertj.core.api.Assertions;
    import org.junit.jupiter.api.Test;
    import org.springframework.context.ApplicationContext;
    import org.springframework.context.annotation.AnnotationConfigApplicationContext;
    import org.springframework.context.annotation.Bean;

    public class StatefulServiceTest {

        @Test
        void statefulServiceSingleton() {

            ApplicationContext ac =
                    new AnnotationConfigApplicationContext(TestConfig.class);

            StatefulService statefulService1 =
                    ac.getBean("statefulService", StatefulService.class);

            StatefulService statefulService2 =
                    ac.getBean("statefulService", StatefulService.class);

            // ThreadA: 사용자 A가 10000원 주문
            statefulService1.order("userA", 10000);

            // ThreadB: 사용자 B가 20000원 주문
            statefulService2.order("userB", 20000);

            // ThreadA: 사용자 A 주문 금액 조회
            int price = statefulService1.getPrice();

            System.out.println("price = " + price);

            // 사용자 A는 10000원을 기대했지만 실제로는 20000원이 나온다
            Assertions.assertThat(price).isEqualTo(20000);
        }

        static class TestConfig {

            @Bean
            public StatefulService statefulService() {
                return new StatefulService();
            }
        }
    }
```
---

### 6-5. 왜 이런 문제가 발생하는가?

- `StatefulService`는 싱글톤 빈이다
- `price` 필드는 **모든 클라이언트가 공유하는 필드**
- 사용자 A의 요청이 끝나기도 전에
  사용자 B가 같은 객체의 `price` 값을 변경해 버린다

결과적으로:
- 사용자 A는 자신의 주문 금액(10000원)이 아니라
- 사용자 B의 주문 금액(20000원)을 보게 된다

실제로 이런 문제는
**실무에서도 몇 년에 한 번씩 반드시 터지는 치명적인 장애 유형**이다.

---

### 6-6. 해결 방법: 무상태(stateless) 설계

상태를 필드에 저장하지 말고,
요청마다 필요한 값은 다음 방식으로 처리해야 한다.

- 메서드 파라미터로 전달
- 메서드 내부 지역 변수 사용
- 반환값으로 결과 전달

즉,
```java
public class StatefulService {

    // 기존의 필드를 제거하고
    // private int price;
    
    // 지역변수를 리턴
    public int order(String name, int price) {
        System.out.println("name = " + name + " price = " + price);
        //this.price = price;
        return price;
    }
    
}
```
이렇게 설계하면:
- 어떤 클라이언트도 다른 클라이언트에 영향을 주지 않는다
- 싱글톤 객체라도 안전하게 사용할 수 있다

---

### 6-7. 정리

- 싱글톤 객체는 반드시 **무상태(stateless)** 로 설계해야 한다
- 필드에 값을 저장하는 순간, 공유 문제가 발생한다
- 스프링 빈은 기본이 싱글톤이므로 더욱 주의해야 한다
- **공유 필드는 항상 의심하고 조심해야 한다**

즉,

> **스프링 빈은 항상 무상태로 설계하자.  
> 상태를 가지는 순간, 대형 장애의 씨앗이 된다.**


## 7. @Configuration과 바이트코드 조작(CGLIB)의 비밀

앞에서 살펴본 AppConfig 코드를 보면,
스프링이 싱글톤을 보장한다고 했음에도 불구하고
코드상으로는 싱글톤이 깨지는 것처럼 보이는 지점이 있다.

### 의문이 생기는 코드

    @Bean
    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }

    @Bean
    public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), discountPolicy());
    }

    @Bean
    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }

겉으로 보면,
- `memberService()` 호출 시 `memberRepository()` 호출
- `orderService()` 호출 시 또 `memberRepository()` 호출

즉,

> `new MemoryMemberRepository()`가  
> **두 번 실행되는 것처럼 보인다**

그렇다면 정말 객체가 두 개 생성되는 걸까?  
결론부터 말하면 **아니다. 싱글톤은 깨지지 않는다.**

---

### 7-1. 자바 코드만 보면 싱글톤이 깨지는 것처럼 보이는 이유

순수 자바 관점에서 이 코드를 해석하면 다음과 같다.

    memberService() 호출
        → memberRepository() 호출
            → new MemoryMemberRepository()

    orderService() 호출
        → memberRepository() 호출
            → new MemoryMemberRepository()

자바 문법만 보면
`memberRepository()` 메서드는 **매번 새로운 객체를 생성하는 코드**다.

👉 이 관점에서 보면  
“싱글톤이 깨지는 게 맞다”라는 의문이 드는 것이 정상이다.

---

### 7-2. 하지만 스프링에서는 상황이 완전히 다르다

핵심은 이 한 줄이다.

    @Configuration

이 어노테이션이 붙는 순간,
`AppConfig`는 **그냥 자바 클래스가 아니다.**

---

### 7-3. @Configuration이 하는 진짜 역할

`@Configuration`이 붙은 클래스는
스프링이 **CGLIB을 사용해 상속 기반 프록시 클래스로 변환**한다.

즉, 실제로 컨테이너에 등록되는 객체는

- `AppConfig` ❌
- `AppConfig$$EnhancerBySpringCGLIB` ⭕

이다.

이 클래스는 다음과 같은 특징을 가진다.

- `@Bean` 메서드를 **오버라이드(재정의)** 한다
- 메서드 호출 시 항상 **스프링 컨테이너를 먼저 조회**한다

---

### 7-4. 실제 동작 흐름 (중요)

#### ① 컨테이너 시작 시

- 스프링 컨테이너가 시작된다
- `@Configuration`이 붙은 AppConfig를 발견한다
- CGLIB으로 프록시 클래스를 생성한다
- 이 프록시 객체를 컨테이너에 등록한다

---

#### ② memberService() 호출 시

    memberService()

- 프록시 객체의 `memberService()`가 호출된다
- 내부에서 `memberRepository()`를 호출한다

⚠️ 이때 호출되는 `memberRepository()`는  
**내가 작성한 원본 메서드가 아니라 프록시가 재정의한 메서드**다.

---

#### ③ 프록시가 memberRepository()를 가로챈다

프록시 내부 로직은 개념적으로 다음과 같다.

    if (이미 memberRepository 빈이 존재하면) {
        return 기존 빈;
    } else {
        새로 생성해서 컨테이너에 등록;
        return 그 객체;
    }

즉,

- 첫 호출 → `new MemoryMemberRepository()` 실행
- 이후 호출 → 이미 생성된 객체 반환

👉 결과적으로 **객체는 단 한 번만 생성된다.**

---

### 7-5. 그래서 싱글톤이 깨지지 않는 이유

정리하면:

- 자바 코드만 보면 `new`가 여러 번 호출되는 것처럼 보인다
- 하지만 실제 실행되는 메서드는
  **CGLIB 프록시가 오버라이드한 메서드**
- 프록시는 항상 컨테이너의 싱글톤 레지스트리를 먼저 조회한다
- 이미 생성된 빈이 있으면 그대로 반환한다

즉,

> **@Configuration + CGLIB 덕분에  
> @Bean 메서드는 싱글톤을 보장받는다**

---

### 7-6. 만약 @Configuration을 제거하면 어떻게 될까?

    //@Configuration
    public class AppConfig {

        @Bean
        public MemberRepository memberRepository() {
            return new MemoryMemberRepository();
        }
    }

이 경우:

- CGLIB 프록시 적용 ❌
- 메서드 호출 가로채기 ❌
- `memberRepository()` 호출 시마다 `new` 실행 ⭕

👉 **싱글톤이 깨진다**

이 때문에 스프링은
**설정 클래스에는 반드시 `@Configuration` 사용을 권장**한다.

---

### 7-7. 핵심 정리

- 스프링의 싱글톤 보장은
  단순한 규칙이나 약속이 아니다
- `@Configuration` + CGLIB 바이트코드 조작으로
  **코드 레벨에서 강제**된다
- 개발자는 객체 생성을 신경 쓰지 않고
  선언적으로 설정만 하면 된다

즉,

> **스프링은  
> 바이트코드 조작을 통해  
> 싱글톤을 깨지지 않게 만든다**

이것이 바로  
**@Configuration과 CGLIB의 진짜 역할이다.**
