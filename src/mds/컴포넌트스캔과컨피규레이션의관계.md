## @Configuration 과 @ComponentScan 최종 정리

스프링 설정과 빈 등록 방식을 정리하면  
`@Configuration` 과 `@ComponentScan` 은 **역할이 명확히 다르며**,  
이 둘을 **조합해서 사용하는 것이 실무의 정석**이다.

---

### 1. `@Configuration`의 역할

`@Configuration` 은 다음 의미를 가진다.

> **“이 클래스는 스프링의 설정 파일이다”**

이 애노테이션이 붙으면 스프링은 해당 클래스를 단순한 자바 클래스가 아니라  
**설정 정보(Configuration Class)** 로 인식한다.

그 결과로 다음 일이 발생한다.

- 설정 클래스로 등록된다
- 내부의 `@Bean` 메서드들이 스프링 빈으로 관리된다
- CGLIB 기반 바이트코드 조작이 적용된다
- `@Bean` 메서드 호출 시 항상 같은 객체를 반환한다
- 즉, **싱글톤이 보장된다**

정리하면,

> **`@Configuration`은  
> 설정 클래스임을 알리고  
> 스프링 빈의 싱글톤을 보장하는 역할을 한다**

---

### 2. `@ComponentScan`의 역할

`@ComponentScan` 의 역할은 명확하다.

> **지정된 패키지를 기준으로  
> `@Component` 계열 애노테이션이 붙은 클래스를 찾아  
> 자동으로 스프링 빈으로 등록한다**

이를 통해 얻는 효과는 다음과 같다.

- `@Bean` 을 하나하나 등록하지 않아도 된다
- 빈 등록 누락을 방지할 수 있다
- 설정 코드가 크게 줄어든다
- 생산성과 유지보수성이 향상된다

즉,

> **`@ComponentScan`은  
> 스프링 빈 등록을 자동화하는 기능이다**

---

### 3. 왜 둘을 조합하는가? (실무 정석)

`@Configuration` 과 `@ComponentScan` 은 **서로 대체 관계가 아니다.**

각자의 책임이 다르다.

| 애노테이션 | 역할 |
|-----------|------|
| `@Configuration` | 설정 클래스 선언 + 싱글톤 보장 |
| `@ComponentScan` | 자동 빈 등록 |

그래서 실무에서는 다음 조합을 기본으로 사용한다.

```java
@Configuration
@ComponentScan("com.example")
public class AppConfig {
}
