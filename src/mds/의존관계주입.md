#  의존관계 자동 주입 (Dependency Injection)

스프링은 객체 간의 의존관계를 개발자가 직접 생성하지 않고,  
**스프링 컨테이너가 자동으로 찾아서 주입**해주는 기능을 제공한다.  
이를 **의존관계 자동 주입(DI)** 이라고 한다.

---

## 1. 다양한 의존관계 주입 방법

의존관계 주입은 크게 4가지 방법이 있다.

- 생성자 주입
- 수정자 주입(setter 주입)
- 필드 주입
- 일반 메서드 주입

---

## 2. 생성자 주입 (권장 ⭐⭐⭐)

### 개념
생성자를 통해 의존관계를 주입하는 방식이다.  
지금까지 우리가 주로 사용했던 방식이 바로 생성자 주입이다.

```java
@Component
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository,
                            DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }
}
```

### 특징
- **생성 시점에 딱 한 번만 호출**되는 것이 보장된다
- **불변(immutable) 설계**가 가능하다
- **필수 의존관계**에 적합하다
- 테스트 시 의존성 누락을 **컴파일 단계에서 발견**할 수 있다

### 중요한 규칙
> **생성자가 1개라면 `@Autowired`는 생략 가능**하다  
> (단, 스프링 컨테이너가 관리하는 **스프링 빈**에 한해서)

```java
@Component
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    public OrderServiceImpl(MemberRepository memberRepository,
                            DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }
}
```

---

## 3. 수정자 주입 (Setter 주입)

### 개념
setter(수정자) 메서드를 통해 의존관계를 주입하는 방식이다.

```java
@Component
public class OrderServiceImpl implements OrderService {

    private MemberRepository memberRepository;
    private DiscountPolicy discountPolicy;

    @Autowired
    public void setMemberRepository(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Autowired
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}
```

### 특징
- **선택적(옵션)** 이거나 **변경 가능성**이 있는 의존관계에 사용
- setter 메서드를 public으로 열어야 하므로 변경 위험이 존재

### 참고
`@Autowired`의 기본 동작은 주입할 대상이 없으면 오류가 발생한다.  
주입할 대상이 없어도 동작하게 하려면 다음처럼 설정한다.

```java
@Autowired(required = false)
public void setSomething(SomeBean bean) {
    // bean이 없으면 이 메서드 자체가 호출되지 않음
}
```

---

## 4. 필드 주입 (비권장 ❌)

### 개념
필드에 직접 `@Autowired`를 붙여 주입하는 방식이다.

```java
@Component
public class OrderServiceImpl implements OrderService {

    @Autowired
    private MemberRepository memberRepository;

    @Autowired
    private DiscountPolicy discountPolicy;
}
```

### 단점
- 외부에서 변경이 불가능해 **테스트하기 어려움**
- DI 프레임워크(스프링 컨테이너) 없이는 동작 불가
- 유지보수/설계 관점에서 권장되지 않음

> 실무에서는 **사용하지 말자**  
> 예외: 테스트 코드, 또는 설정 목적의 `@Configuration` 등 아주 제한적인 용도

---

## 5. 일반 메서드 주입

### 개념
일반 메서드를 통해 여러 의존관계를 한 번에 주입받는 방식이다.

```java
@Component
public class OrderServiceImpl implements OrderService {

    private MemberRepository memberRepository;
    private DiscountPolicy discountPolicy;

    @Autowired
    public void init(MemberRepository memberRepository,
                     DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }
}
```

### 특징
- 한 번에 여러 필드를 주입할 수 있음
- 일반적으로 자주 사용되지는 않음

---

## 6. 옵션 처리 (주입 대상이 없어도 동작하게 하기)

주입할 스프링 빈이 없어도 동작해야 할 때가 있다.  
하지만 `@Autowired` 기본값은 `required=true`라서 대상이 없으면 오류가 난다.

옵션 처리 방법은 다음과 같다.

- `@Autowired(required=false)` : 대상이 없으면 **메서드 호출 자체가 안 됨**
- `@Nullable` : 대상이 없으면 **null 주입**
- `Optional<T>` : 대상이 없으면 **Optional.empty 주입**

```java
// 호출 안됨
@Autowired(required = false)
public void setNoBean1(Member member) {
    System.out.println("setNoBean1 = " + member);
}

// null 호출
@Autowired
public void setNoBean2(@Nullable Member member) {
    System.out.println("setNoBean2 = " + member);
}

// Optional.empty 호출
@Autowired
public void setNoBean3(Optional<Member> member) {
    System.out.println("setNoBean3 = " + member);
}
```

> 위 예시에서 `Member`는 스프링 빈이 아니라고 가정한다.
> 추가적인 예시는 AutoWiredTest.java 참고 

---

## 7. 생성자 주입을 선택해라! (왜 권장되는가)

### 7.1 불변(Immutable)
대부분의 의존관계는 애플리케이션 종료 시점까지 변할 일이 없다.  
오히려 **변하면 안 되는 경우가 더 많다.**

- 수정자 주입은 setter를 public으로 열어야 해서 변경 가능성이 생김
- 생성자 주입은 생성 시점 1회 주입 → 이후 변경 불가

### 7.2 누락 방지 (테스트에서 강력)
프레임워크 없이 순수 자바 단위 테스트를 하면, setter 주입은 누락되어도 컴파일이 된다.  
그 결과 런타임에 NPE가 발생한다.

반면 생성자 주입은 필수 의존성을 빼먹으면 **컴파일 단계에서 바로 오류**가 난다.

### 7.3 final 키워드 사용 가능
생성자 주입은 필드에 `final`을 붙일 수 있다.  
그래서 생성자에서 값 대입 누락이 있으면 컴파일 에러로 잡아준다.

```java
@Component
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    public OrderServiceImpl(MemberRepository memberRepository,
                            DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        // discountPolicy 대입 누락 시 컴파일 오류 발생
    }
}
```

> **컴파일 오류는 세상에서 가장 빠르고 좋은 오류다.**

---

## 8. Lombok과 최신 트렌드

생성자 주입은 코드가 길어질 수 있다.  
Lombok의 `@RequiredArgsConstructor`를 쓰면 **final 필드를 모아 생성자를 자동 생성**해준다.

```java
@Component
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
}
```

이 코드는 아래와 동일한 생성자가 컴파일 시점에 생성된다.

```java
public OrderServiceImpl(MemberRepository memberRepository,
                        DiscountPolicy discountPolicy) {
    this.memberRepository = memberRepository;
    this.discountPolicy = discountPolicy;
}
```

---

## 9. 조회 빈이 2개 이상일 때 문제

`@Autowired`는 기본적으로 **타입(Type) 기준으로 조회**한다.

```java
@Autowired
private DiscountPolicy discountPolicy;
```

만약 다음처럼 동일 타입 빈이 2개라면 오류가 발생한다.

- `FixDiscountPolicy`
- `RateDiscountPolicy`

오류 예:
- `NoUniqueBeanDefinitionException`

---

## 10. 해결 방법: @Autowired 필드명 / @Qualifier / @Primary

동일 타입 빈이 2개 이상일 때 해결 방법은 다음 순서로 이해하면 된다.

1) 필드명(파라미터명) 매칭
2) `@Qualifier`
3) `@Primary`

### 10.1 @Autowired 필드명 매칭
타입 매칭 결과가 2개 이상이면, **필드명/파라미터명으로 빈 이름을 추가 매칭**한다.

```java
@Autowired
private DiscountPolicy rateDiscountPolicy;
```

---

### 10.2 @Qualifier
추가 구분자를 지정해서 원하는 빈을 정확히 선택한다.

```java
@Component
@Qualifier("mainDiscountPolicy")
public class RateDiscountPolicy implements DiscountPolicy {}
```

주입 시:

```java
@Autowired
public OrderServiceImpl(MemberRepository memberRepository,
                        @Qualifier("mainDiscountPolicy") DiscountPolicy discountPolicy) {
    this.memberRepository = memberRepository;
    this.discountPolicy = discountPolicy;
}
```

**@Qualifier 동작 순서**
1. @Qualifier끼리 매칭
2. 빈 이름 매칭
3. 없으면 예외 발생

---

### 10.3 @Primary
여러 빈이 매칭되면 **우선권(기본값)** 을 준다.

```java
@Component
@Primary
public class RateDiscountPolicy implements DiscountPolicy {}

@Component
public class FixDiscountPolicy implements DiscountPolicy {}
```

> 우선순위는 **@Qualifier가 @Primary보다 높다.**  
> (자동보다 수동, 넓은 선택보다 좁은 선택이 우선)

---

## 11. 애노테이션 직접 만들기 (컴파일 타입 체크 목적)

문자열 `@Qualifier("mainDiscountPolicy")`는 오타를 컴파일 단계에서 잡기 어렵다.  
그래서 커스텀 애노테이션으로 감싸서 사용한다.

```java
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER,
         ElementType.TYPE, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Qualifier("mainDiscountPolicy")
public @interface MainDiscountPolicy {}
```

사용:

```java
@Component
@MainDiscountPolicy
public class RateDiscountPolicy implements DiscountPolicy {}
```

주입:

```java
@Autowired
public OrderServiceImpl(MemberRepository memberRepository,
                        @MainDiscountPolicy DiscountPolicy discountPolicy) {
    this.memberRepository = memberRepository;
    this.discountPolicy = discountPolicy;
}
```

---

## 12. 조회한 빈이 모두 필요할 때 (List, Map)

의도적으로 해당 타입의 빈이 전부 필요한 경우가 있다.  
예: 전략 패턴(할인 정책 선택)

```java
public class DiscountService {

    private final Map<String, DiscountPolicy> policyMap;
    private final List<DiscountPolicy> policies;

    public DiscountService(Map<String, DiscountPolicy> policyMap,
                           List<DiscountPolicy> policies) {
        this.policyMap = policyMap;
        this.policies = policies;
    }

    public int discount(Member member, int price, String discountCode) {
        DiscountPolicy discountPolicy = policyMap.get(discountCode);
        return discountPolicy.discount(member, price);
    }
}
```

- `Map<String, DiscountPolicy>` : key=빈 이름, value=빈 객체
- `List<DiscountPolicy>` : 해당 타입의 모든 빈 목록

---

## 13. 자동 등록 vs 수동 등록 (실무 운영 기준)

### 13.1 자동 등록(기본) 권장
업무 로직(Controller/Service/Repository)은 개수가 많고 패턴이 유사하다.  
그래서 컴포넌트 스캔 + 자동 주입을 적극 사용한다.

- 업무 로직 빈: 컨트롤러, 서비스, 리포지토리 등
- 변경이 잦고 수가 많음
- 자동 등록이 생산성과 유지보수에 유리

### 13.2 수동 등록 권장 케이스
기술 지원 로직은 개수는 적지만 시스템 전반에 영향이 크다.  
그래서 설정 파일에 **명시적으로 드러나게** 등록하는 게 좋다.

- 기술 지원 빈: AOP, 공통 로그, 특정 정책 묶음, 커스텀 인프라 빈 등
- 적용 여부 파악이 어려운 경우가 많음
- 설정 정보에 딱 보이게 하는 게 유지보수에 유리

### 13.3 다형성을 적극 활용하는 비즈니스 로직
`DiscountPolicy`처럼 구현체가 여러 개이고 Map/List로 엮여 들어가는 구조는  
“어떤 빈이 들어가는지”를 한눈에 파악하기 어려울 수 있다.

이 경우는 다음 중 하나를 고려한다.

- (1) 별도 설정 클래스로 수동 등록해 한눈에 보이게 만들기
- (2) 관련 구현체를 특정 패키지로 모아서 관리

수동 등록 예:

```java
@Configuration
public class DiscountPolicyConfig {

    @Bean
    public DiscountPolicy rateDiscountPolicy() {
        return new RateDiscountPolicy();
    }

    @Bean
    public DiscountPolicy fixDiscountPolicy() {
        return new FixDiscountPolicy();
    }
}
```

---

## 14. 최종 정리

- 기본은 **생성자 주입** (불변/필수/누락 방지/테스트 친화적)
- 옵션이 필요한 경우에만 수정자 주입을 추가로 고려
- 필드 주입은 실무에서 지양
- 자동 등록을 기본으로, 기술 지원/다형성 핵심 영역은 수동 등록을 고민

> **항상 생성자 주입을 선택하자.**  
> **옵션이 필요할 때만 수정자 주입을 사용하자.**  
> **필드 주입은 사용하지 말자.**
